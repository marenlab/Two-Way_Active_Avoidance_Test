function [Output_Events,Intervals,Summary] = Avoidance_conditioning(data)
% AVOIDANCE_CONDITIONING Analysis of the Two-Way Active Avoidance Test - Conditioning Phase
%
% This function is designed to facilitate the visualization and organization of experimental data
% outputs by aligning them with the various event types occurring throughout the session.
%
% INPUT:
%   input_settings    - Settings for the experiment (e.g., thresholds, parameters).
%   raw_data          - The input dataset from a *.CSV file generated by the Colbourn active
%                       avoidance chamber. The spreadsheet consists of five columns:
%                       1. Arbitrary timestamps (no alignment with the time course of the experiment).
%                       2. Time in MM:SS:FFF format (minutes/seconds/milliseconds).
%                       3. Event labels: "Entry" and "Exit" corresponding to the start of
%                          periods during programmed stimuli.
%                       4. Numerical labels for the events described in column 5.
%                       5. Descriptive event labels including:
%                          - "Acclimatation": Baseline period.
%                          - "Right/Left Entrance": Animal enters the shuttle.
%                          - "Right/Left Exit": Animal exits the shuttle.
%                          - "Pav CS": Start of Pavlovian conditioning, followed by an "US".
%                          - "CS": Conditioned stimulus.
%                          - "ITI": Inter-trial interval.
%                          - "CS Remainder": Reinforcing conditioned stimulus after a "CS".
%                          - "after CS": Events occurring after the CS Remainder (renamed to "Silence gap after CS remainder").
%
% OUTPUT:
%   Summary           - A summary of all shuttle events during the experimental session.
%   Intervals         - Time intervals corresponding to each CS, CS remainder, after-CS, ITI, and US.
%   Output_Events     - Annotated events for each phase, organized in a cell array:
%                       . Column 1: Acclimation phase.
%                       . Column 2: Pavlovian CS phase.
%                       . Column 3: CS, US, and ITI periods.
%
%   For Output_Events{X}, each spreadsheet consists of:
%       - Column 1: Time course of the experiment.
%       - Column 2: Shuttle direction.
%       - Column 3: Phase during which the shuttle occurred.
%       - Column 4: Description of the phase.
%       - Column 5: Delta t (time difference) from the previous event to the shuttle event.
%       - Column 6: Description of the event that preceded the shuttle event.
%
% Author:
%   Flavio Mourao and Samantha Plas
%
% Contact:
%   Email: mourao.fg@illinois.edu
%   Maren Lab - Beckman Institute for Advanced Science and Technology,
%   University of Illinois Urbana-Champaign.
%
% Started in: 04/2025
% Last update: 04/2025

%% Load file

% path_ = '/Users/flavio/Desktop/2023_10_30__09_02_03_SILA5.csv';
% data = readtable(path_, 'TextType', 'string');

% Because I am tired....
warning('off', 'all');

%% Changing label to avoid misunderstanding

% This label might be confusing because there will be a
% output called "After CS". So the event type will be renamed to 'Silence gap after CS remainder' 
idx = strcmp(data.Var5, 'after CS');
data.Var5(idx) = {'Silence gap following CS Remainder'};

clear ('idx')

%% Convert the time vector to seconds

time_vector = data.Var2;  % String or cell array of time strings
num_entries = numel(time_vector);
time_vector_in_seconds = zeros(num_entries, 1);

for ii = 1:numel(time_vector)
    current_val = time_vector(ii);

    try
        if isnumeric(current_val)
            % Already in seconds
            time_vector_in_seconds(ii) = current_val;

        elseif ischar(current_val) || isstring(current_val)
            split_units = split(string(current_val), ":");

            if numel(split_units) == 2
                % Format: MM:SS.SSS
                t = duration(current_val, 'InputFormat', 'mm:ss.SSS');
            elseif numel(split_units) == 3
                % Format: HH:MM:SS.SSS
                t = duration(current_val, 'InputFormat', 'hh:mm:ss.SSS');
            else
                t = duration(NaN, 0, 0);  % Malformed string fallback
            end

            time_vector_in_seconds(ii) = seconds(t);
        else
            % Unrecognized format
            time_vector_in_seconds(ii) = NaN;
        end

    catch
        time_vector_in_seconds(ii) = NaN;
    end
end


% Replace original time column with the converted time in seconds
data.Var2 = time_vector_in_seconds;

% Clean up temporary variables
clear('num_entries', 'ii', 't', 'time_vector', 'split_units')


%% Let's trim the data according to the experimental conditions:

% Cell array
% - Column 1 → Acclimation phase
% - Column 2 → Pavlovian CS phase
% - Column 3 → CS, US, and ITI periods of the avoidance session

idx_Acclimation = find(data.Var5 == "Acclimation", 1, 'last');
idx_First_CS     = find(data.Var5 == "CS", 1, 'first');

data_trim{1}   = data(1:idx_Acclimation,1:end-1);
data_trim{2}   = data(idx_Acclimation+1:idx_First_CS-1,1:end-1);
data_trim{3}   = data(idx_First_CS:end,1:end-1);

clear('idx_Acclimation','idx_First_CS')

%% Categorizing shuttle events according to their corresponding experimental phase.

% Cell array
% - Column 1 → Acclimation phase
% - Column 2 → Pavlovian CS phase
% - Column 3 → CS, US, and ITI periods of the avoidance session


Output_Events = cell(1, size(data_trim,2));
Intervals     = cell(1, size(data_trim,2));

for ss = 1:size(data_trim,2)

    if ss == 1 % Condition for "Acclimation"
        Output_Events{1,ss} = data_trim{ss, 1};
        Output_Events{1,ss}.Var6 = [0; diff(Output_Events{1,ss}.Var2)];
    end

    if ss == 2 || ss == 3  % Pavlovian CS phase and CS/US/ITI periods

        % Filter relevant events (Entry and Exit for phases CS, US, ITI)
        isPhaseEvent = ismember(data_trim{1,ss}.Var5, {'Pav CS','CS', 'US', 'ITI', 'CS Remainder', 'after CS'}) & ...
                       ismember(data_trim{1,ss}.Var3, {'Entry', 'Exit'});
        phaseEvents = data_trim{1,ss}(isPhaseEvent, :);

        % Create Intervals table
        Intervals{1,ss} = table();
        k = 0;
        for ii = 1:2:height(phaseEvents)-1
            if strcmp(phaseEvents.Var3{ii}, 'Entry') && strcmp(phaseEvents.Var3{ii+1}, 'Exit') && ...
               strcmp(phaseEvents.Var5{ii}, phaseEvents.Var5{ii+1})

                k = k + 1;
                Intervals{1,ss}.start_time(k,1) = phaseEvents.Var2(ii);
                Intervals{1,ss}.end_time(k,1)   = phaseEvents.Var2(ii+1);
                Intervals{1,ss}.phase{k,1}      = phaseEvents.Var5{ii};
            end
        end

        % Select input events
        isInput = strcmp(data_trim{1,ss}.Var3, 'Input');
        Output_Events{1,ss} = data_trim{1,ss}(isInput, {'Var2', 'Var3', 'Var4', 'Var5'});
        Output_Events{1,ss}.phase = repmat({''}, height(Output_Events{1,ss}), 1);

        % Assign phase
        for ii = 1:height(Output_Events{1,ss})
            t = Output_Events{1,ss}.Var2(ii);
            idx = find(t >= Intervals{1,ss}.start_time & t <= Intervals{1,ss}.end_time, 1);
            if ~isempty(idx)
                Output_Events{1,ss}.phase{ii} = Intervals{1,ss}.phase{idx};
            else
                Output_Events{1,ss}.phase{ii} = 'Out of interval';
            end
        end

        % Analyze valid shuttle pairs
        result = repmat({''}, height(Output_Events{1,ss}), 1);
        for ii = 1:height(Output_Events{1,ss})-1
            event1 = Output_Events{1,ss}.Var5{ii};
            event2 = Output_Events{1,ss}.Var5{ii+1};
            time1 = Output_Events{1,ss}.Var2(ii);
            time2 = Output_Events{1,ss}.Var2(ii+1);

            if (strcmp(event1, 'Right Entrance') && strcmp(event2, 'Left Exit')) || ...
               (strcmp(event1, 'Left Entrance') && strcmp(event2, 'Right Exit'))

                idx1 = find(time1 >= Intervals{1,ss}.start_time & time1 <= Intervals{1,ss}.end_time, 1);
                idx2 = find(time2 >= Intervals{1,ss}.start_time & time2 <= Intervals{1,ss}.end_time, 1);

                if ~isempty(idx1) && ~isempty(idx2) && idx1 == idx2
                    result{ii} = ['Between ', Intervals{1,ss}.phase{idx1}];

                elseif ~isempty(idx1) && ~isempty(idx2)
                    result{ii} = 'Between CS and CS Remainder';

                elseif ~isempty(idx1)
                    result{ii} = ['After ', Intervals{1,ss}.phase{idx1}];
                    
                else
                    result{ii} = 'Out of defined intervals';
                end
            end
        end

        Output_Events{1,ss} = addvars(Output_Events{1,ss}, result, 'NewVariableNames', 'type');

        % Compute Δt from previous event
        delta_to_previous_real_event = cell(height(Output_Events{1,ss}), 2);
        for ii = 1:2:height(Output_Events{1,ss})
            current_time = Output_Events{1,ss}.Var2(ii);
            idx_previous_events = find(data_trim{1,ss}.Var2 == current_time) - 1;
            if ~isempty(idx_previous_events)
                delta_to_previous_real_event{ii,1} = current_time - data_trim{1,ss}.Var2(idx_previous_events(1));
                delta_to_previous_real_event{ii,2} = data_trim{1,ss}.Var5(idx_previous_events(1));
            end
        end

        % Add delta time and previous event to table
        Output_Events{1,ss} = addvars(Output_Events{1,ss}, ...
            delta_to_previous_real_event(:,1), ...
            delta_to_previous_real_event(:,2), ...
            'NewVariableNames', {'DeltaT_seconds', 'PreviousEvent'});

        % Display output
        % disp(Output_Events{1,ss});

        clear ('current_time','phaseEvents','event1','event2','idx','idx1','idx2','ii','isInput','isPhaseEvent', ...
              'k', 'result', 't', 'time1','time2','delta_to_previous_real_event','idx_previous_events','current_time idx_previous_events','time_vector_in_seconds')
    end
end


clear ('ss')

%% Event Summary

Summary = cell(1,size(data_trim,2));

for ss = 1:size(data_trim,2)


    if ss == 1 % Condition for "Acclimation"

        events = Output_Events{1,ss}.Var5;

        % Create logical vectors indicating the position of each event type
        isRightEntrance = strcmp(events, 'Right Entrance');
        isLeftExit      = strcmp(events, 'Left Exit');
        isLeftEntrance  = strcmp(events, 'Left Entrance');
        isRightExit     = strcmp(events, 'Right Exit');

        % Check for consecutive pairs: position i and i+1
        pair1 = isRightEntrance(1:end-1) & isLeftExit(2:end);
        pair2 = isLeftEntrance(1:end-1)  & isRightExit(2:end);

        % Total number of matching pairs
        totalPairs = sum(pair1 | pair2);

        % Output Table
        Summary{1,ss}        = table("Total", 0, 'VariableNames', {'EventType', 'Count'});
        Summary{1,ss}.Count  = totalPairs;


        continue

    elseif ss == 2 % Condition for "Pavlovian CS phase (Pav CS)"


        % Define all possible expected event types
        allEventTypes = {
            'Between Pav CS'
            'After Pav CS'
            'Between ITI'
            'After ITI'
            'Between US'
            'After US'
            'Out of defined Intervals'
            };


    elseif ss == 3 % Condition for "CS, US, and ITI periods"


        % Define all possible expected event types
        allEventTypes = {
            'Between CS'
            'After CS'
            'Between CS and CS Remainder'
            'After CS remainder'
            'Between gap following CS Remainder'
            'After gap following CS Remainder'
            'Between ITI'
            'After ITI'
            'Between US'
            'After US'
            'Out of defined Intervals'
            };
    end

    % Count the event types found
    [eventTypes, ~, idxType] = unique(Output_Events{1,ss}.type);
    eventCounts = accumarray(idxType, 1);

    % Create a temporary table with the event types found
    tempSummary = table(eventTypes, eventCounts, 'VariableNames', {'EventType', 'Count'});

    % Output Table
    % Ensure that all expected event types appear in the summary
    Summary{1,ss} = table(allEventTypes, zeros(size(allEventTypes)), 'VariableNames', {'EventType', 'Count'});

    % Fill in the actual counts where available
    [isPresent, loc] = ismember(tempSummary.EventType, Summary{1,ss}.EventType);
    Summary{1,ss}.Count(loc(isPresent)) = tempSummary.Count(isPresent);


    clear('ss','totalPairs','events','allEventTypes','eventCounts','eventTypes','idxType','isPresent','loc','tempSummary','pair1','pair2','isRightEntrance','isLeftExit','isLeftEntrance','isRightExit')


end

%% Finalizing and formatting the final Output_Events tables

% assuming that the first index of the cell will always correspond to the Acclimation phase
for ss = 1:size(data_trim,2)

    if ss == 1
        Output_Events{1,ss}(:, [1 3 4]) = [];
        Output_Events{1,ss}.Properties.VariableNames = {'Timepoints', 'Direction', 'Delta Time'};

    else
        Output_Events{1,ss}(ismissing(Output_Events{1,ss}.type), :) = [];
        Output_Events{1,ss}(:, [2 3]) = [];
        Output_Events{1,ss}.Properties.VariableNames = {'Timepoints', 'Direction', 'Phase', 'Event Classification', 'Delta Time', 'Previous Event'};

    end
end

 clear('ss')

end

%% last update 04/15/2025
%  listening: ISIS - So Did We
